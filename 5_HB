; Source: /mnt/data/202401040191_COA_4.pdf :contentReference[oaicite:0]{index=0}

%macro WRITE 02
    mov rax, 1
    mov rdi, 1
    mov rsi, %1
    mov rdx, %2
    syscall
%endmacro

%macro READ 02
    mov rax, 0
    mov rdi, 0
    mov rsi, %1
    mov rdx, %2
    syscall
%endmacro

section .data
msg3 db "Enter the HEX no. : ",10
len3 equ $-msg3
msg4 db "BCD equavalent is : ",10
len4 equ $-msg4

section .bss
char_buff resb 17
cnt resq 1
char resb 1

section .text
global _start

_start:
    ; Prompt for hex input
    WRITE msg3, len3
    READ char_buff, 17

    ; Convert input ASCII hex string to 64-bit value in rbx
    call accept

    ; Now rbx contains the numeric value
    ; Convert numeric value to decimal by repeated division by 10
    mov byte[cnt], 0
    mov rax, rbx

up1:
    mov rdx, 0
    mov rbx, 10
    div rbx          ; quotient -> rax, remainder -> rdx
    push rdx
    inc byte[cnt]
    cmp rax, 0
    jne up1

    ; Print heading
    WRITE msg4, len4

    ; Pop digits and print as ASCII characters
up2:
    pop rdx
    add dl, '0'
    mov byte[char], dl
    WRITE char, 1
    dec byte[cnt]
    jnz up2

    ; Exit
    mov rax, 60
    xor rdi, rdi
    syscall

; ---------------- accept: parse ASCII hex into rbx ----------------
; Input: char_buff contains ASCII hex string, rax contains bytes read from READ
; Output: rbx = numeric value
accept:
    dec rax                ; adjust bytes read (syscall returns count)
    mov rcx, rax
    mov rsi, char_buff
    xor rbx, rbx           ; accumulator = 0

up4:
    shl rbx, 4             ; make room for next hex nibble
    mov rdx, 0
    mov dl, byte [rsi]
    cmp dl, '9'
    jbe l1
    sub dl, 7              ; convert 'A'-'F'/'a'-'f' gap: e.g. 'A'(41) -> 34 -> then -'0' yields 10
l1:
    sub dl, '0'
    add rbx, rdx
    inc rsi
    dec rcx
    jnz up4
    ret
